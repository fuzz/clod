{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}

-- |
-- Module      : Clod.Config
-- Description : Configuration handling for the Clod application
-- Copyright   : (c) Fuzz Leonard, 2025
-- License     : MIT
-- Maintainer  : cyborg@bionicfuzz.com
-- Stability   : experimental
--
-- This module provides functions for handling configuration options
-- including environment variables and default values.

module Clod.Config
  ( -- * Configuration functions
    configDirName
  , clodIgnoreFile
  , clodConfigDir
  , getDataFileName
  
  -- * File type configurations
  , FileTypes(..)
  , BinarySignature(..)
  , BinarySignatures(..)
  , loadFileTypes
  , loadBinarySignatures
  ) where

import Control.Exception (SomeException, catch)
import Data.Word (Word8)
import Dhall (FromDhall, ToDhall, auto, input)
import GHC.Generics (Generic)
import System.Environment (lookupEnv)
import System.FilePath ((</>))
import qualified Data.Text as T
import qualified Paths_clod as Paths

-- | Get configuration directory name
--
-- Returns the configuration directory name, checking the CLOD_DIR
-- environment variable first and falling back to ".clod" if not set.
--
-- @
-- configDir <- configDirName  -- Returns ".clod" or value of CLOD_DIR
-- @
configDirName :: IO String
configDirName = do
  envValue <- lookupEnv "CLOD_DIR"
  return $ case envValue of
    Just value | not (null value) -> value
    _                            -> ".clod"

-- | Get clodignore file name
--
-- Returns the clodignore file name, checking the CLODIGNORE
-- environment variable first and falling back to ".clodignore" if not set.
--
-- @
-- ignoreFile <- clodIgnoreFile  -- Returns ".clodignore" or value of CLODIGNORE
-- @
clodIgnoreFile :: IO String
clodIgnoreFile = do
  envValue <- lookupEnv "CLODIGNORE"
  return $ case envValue of
    Just value | not (null value) -> value
    _                            -> ".clodignore"

-- | Build the config directory path from project root
--
-- @
-- configDir <- clodConfigDir "/path/to/project"  -- Returns "/path/to/project/.clod" or environment override
-- @
clodConfigDir :: FilePath -> IO FilePath
clodConfigDir rootPath = do
  dirName <- configDirName
  return $ rootPath </> dirName

-- | Data type for file type configurations
data FileTypes = FileTypes
  { textExtensions :: [String]
  , binaryExtensions :: [String]
  , textSpecialCases :: [String]
  , binarySpecialCases :: [String]
  } deriving (Show, Generic)

instance FromDhall FileTypes
instance ToDhall FileTypes

-- | Data type for binary file signatures
data BinarySignature = BinarySignature
  { name :: String
  , bytes :: [Word8]
  } deriving (Show, Generic)

instance FromDhall BinarySignature
instance ToDhall BinarySignature

-- | Container for binary signatures
newtype BinarySignatures = BinarySignatures
  { signatures :: [BinarySignature]
  } deriving (Show, Generic)

instance FromDhall BinarySignatures
instance ToDhall BinarySignatures

-- | Get the path to a data file included with the package
-- This uses the Paths_clod module generated by Cabal
getDataFileName :: FilePath -> IO FilePath
getDataFileName = Paths.getDataFileName

-- | Load file type configurations from Dhall
-- Returns default values if the configuration file cannot be loaded
loadFileTypes :: IO FileTypes
loadFileTypes = do
  path <- getDataFileName "resources/file_types.dhall"
  (input auto (T.pack path) :: IO FileTypes) `catch` \(_ :: SomeException) -> 
    pure defaultFileTypes

-- | Load binary signatures from Dhall
-- Returns default values if the configuration file cannot be loaded
loadBinarySignatures :: IO BinarySignatures
loadBinarySignatures = do
  path <- getDataFileName "resources/binary_signatures.dhall"
  (input auto (T.pack path) :: IO BinarySignatures) `catch` \(_ :: SomeException) -> 
    pure defaultBinarySignatures

-- | Default file types in case the configuration file cannot be loaded
defaultFileTypes :: FileTypes
defaultFileTypes = FileTypes
  { textExtensions = 
      [ ".txt", ".md", ".html", ".js", ".css", ".py", ".hs", ".c", ".h", ".json", ".xml", ".yml" ]
  , binaryExtensions = 
      [ ".pdf", ".jpg", ".png", ".gif", ".exe", ".zip", ".jar", ".bin" ]
  , textSpecialCases = 
      [ "Makefile", "Dockerfile", "LICENSE", "README" ]
  , binarySpecialCases = 
      [ ".min.js", ".bundle.js" ]
  }

-- | Default binary signatures in case the configuration file cannot be loaded
defaultBinarySignatures :: BinarySignatures
defaultBinarySignatures = BinarySignatures
  { signatures =
      [ BinarySignature "JPEG" [0xFF, 0xD8, 0xFF]
      , BinarySignature "PNG" [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A]
      , BinarySignature "PDF" [0x25, 0x50, 0x44, 0x46]
      , BinarySignature "ZIP" [0x50, 0x4B, 0x03, 0x04]
      ]
  }
